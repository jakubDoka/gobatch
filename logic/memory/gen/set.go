// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package gen

// Float32Set uses binary search to store comparable elements
// it acts as normal Set though, with performance advantage
// over map
type Float32Set []float32

// Has returns whether set has the value
func (s *Float32Set) Has(val float32) bool {
	_, ok := s.find(val)
	return ok
}

// Remove removes the value or returns false if value is not present
func (s *Float32Set) Remove(val float32) bool {
	idx, ok := s.find(val)
	if !ok {
		return false
	}
	v := *s
	*s = append(v[:idx], v[idx+1:]...)
	return true
}

// Insert inserts the element or returns false if element already is present
func (s *Float32Set) Insert(val float32) bool {
	idx, ok := s.find(val)
	if ok {
		return false
	}

	dv := *s
	e := len(dv)
	dv = append(dv, val)
	for i := e - 1; i >= idx; i-- {
		dv[i+1] = dv[i]
	}
	dv[idx] = val
	*s = dv
	return true
}

func (s *Float32Set) find(e float32) (int, bool) {
	v := *s
	start, end := 0, len(v)
	if start == end {
		return 0, false
	}

	if end < 17 { // benchmarked value
		for i := range v {
			if v[i] == e {
				return i, true
			}
		}

		return end, false
	}

	for {
		mid := start + (end-start)/2
		val := v[mid]
		if val == e {
			return mid, true
		} else if val > e {
			end = mid + 0
		} else {
			start = mid + 1
		}

		if start == end {
			return start, start < len(v) && v[start] == e
		}
	}
}

// Float64Set uses binary search to store comparable elements
// it acts as normal Set though, with performance advantage
// over map
type Float64Set []float64

// Has returns whether set has the value
func (s *Float64Set) Has(val float64) bool {
	_, ok := s.find(val)
	return ok
}

// Remove removes the value or returns false if value is not present
func (s *Float64Set) Remove(val float64) bool {
	idx, ok := s.find(val)
	if !ok {
		return false
	}
	v := *s
	*s = append(v[:idx], v[idx+1:]...)
	return true
}

// Insert inserts the element or returns false if element already is present
func (s *Float64Set) Insert(val float64) bool {
	idx, ok := s.find(val)
	if ok {
		return false
	}

	dv := *s
	e := len(dv)
	dv = append(dv, val)
	for i := e - 1; i >= idx; i-- {
		dv[i+1] = dv[i]
	}
	dv[idx] = val
	*s = dv
	return true
}

func (s *Float64Set) find(e float64) (int, bool) {
	v := *s
	start, end := 0, len(v)
	if start == end {
		return 0, false
	}

	if end < 17 { // benchmarked value
		for i := range v {
			if v[i] == e {
				return i, true
			}
		}

		return end, false
	}

	for {
		mid := start + (end-start)/2
		val := v[mid]
		if val == e {
			return mid, true
		} else if val > e {
			end = mid + 0
		} else {
			start = mid + 1
		}

		if start == end {
			return start, start < len(v) && v[start] == e
		}
	}
}

// IntSet uses binary search to store comparable elements
// it acts as normal Set though, with performance advantage
// over map
type IntSet []int

// Has returns whether set has the value
func (s *IntSet) Has(val int) bool {
	_, ok := s.find(val)
	return ok
}

// Remove removes the value or returns false if value is not present
func (s *IntSet) Remove(val int) bool {
	idx, ok := s.find(val)
	if !ok {
		return false
	}
	v := *s
	*s = append(v[:idx], v[idx+1:]...)
	return true
}

// Insert inserts the element or returns false if element already is present
func (s *IntSet) Insert(val int) bool {
	idx, ok := s.find(val)
	if ok {
		return false
	}

	dv := *s
	e := len(dv)
	dv = append(dv, val)
	for i := e - 1; i >= idx; i-- {
		dv[i+1] = dv[i]
	}
	dv[idx] = val
	*s = dv
	return true
}

func (s *IntSet) find(e int) (int, bool) {
	v := *s
	start, end := 0, len(v)
	if start == end {
		return 0, false
	}

	if end < 17 { // benchmarked value
		for i := range v {
			if v[i] == e {
				return i, true
			}
		}

		return end, false
	}

	for {
		mid := start + (end-start)/2
		val := v[mid]
		if val == e {
			return mid, true
		} else if val > e {
			end = mid + 0
		} else {
			start = mid + 1
		}

		if start == end {
			return start, start < len(v) && v[start] == e
		}
	}
}

// Int16Set uses binary search to store comparable elements
// it acts as normal Set though, with performance advantage
// over map
type Int16Set []int16

// Has returns whether set has the value
func (s *Int16Set) Has(val int16) bool {
	_, ok := s.find(val)
	return ok
}

// Remove removes the value or returns false if value is not present
func (s *Int16Set) Remove(val int16) bool {
	idx, ok := s.find(val)
	if !ok {
		return false
	}
	v := *s
	*s = append(v[:idx], v[idx+1:]...)
	return true
}

// Insert inserts the element or returns false if element already is present
func (s *Int16Set) Insert(val int16) bool {
	idx, ok := s.find(val)
	if ok {
		return false
	}

	dv := *s
	e := len(dv)
	dv = append(dv, val)
	for i := e - 1; i >= idx; i-- {
		dv[i+1] = dv[i]
	}
	dv[idx] = val
	*s = dv
	return true
}

func (s *Int16Set) find(e int16) (int, bool) {
	v := *s
	start, end := 0, len(v)
	if start == end {
		return 0, false
	}

	if end < 17 { // benchmarked value
		for i := range v {
			if v[i] == e {
				return i, true
			}
		}

		return end, false
	}

	for {
		mid := start + (end-start)/2
		val := v[mid]
		if val == e {
			return mid, true
		} else if val > e {
			end = mid + 0
		} else {
			start = mid + 1
		}

		if start == end {
			return start, start < len(v) && v[start] == e
		}
	}
}

// Int32Set uses binary search to store comparable elements
// it acts as normal Set though, with performance advantage
// over map
type Int32Set []int32

// Has returns whether set has the value
func (s *Int32Set) Has(val int32) bool {
	_, ok := s.find(val)
	return ok
}

// Remove removes the value or returns false if value is not present
func (s *Int32Set) Remove(val int32) bool {
	idx, ok := s.find(val)
	if !ok {
		return false
	}
	v := *s
	*s = append(v[:idx], v[idx+1:]...)
	return true
}

// Insert inserts the element or returns false if element already is present
func (s *Int32Set) Insert(val int32) bool {
	idx, ok := s.find(val)
	if ok {
		return false
	}

	dv := *s
	e := len(dv)
	dv = append(dv, val)
	for i := e - 1; i >= idx; i-- {
		dv[i+1] = dv[i]
	}
	dv[idx] = val
	*s = dv
	return true
}

func (s *Int32Set) find(e int32) (int, bool) {
	v := *s
	start, end := 0, len(v)
	if start == end {
		return 0, false
	}

	if end < 17 { // benchmarked value
		for i := range v {
			if v[i] == e {
				return i, true
			}
		}

		return end, false
	}

	for {
		mid := start + (end-start)/2
		val := v[mid]
		if val == e {
			return mid, true
		} else if val > e {
			end = mid + 0
		} else {
			start = mid + 1
		}

		if start == end {
			return start, start < len(v) && v[start] == e
		}
	}
}

// Int64Set uses binary search to store comparable elements
// it acts as normal Set though, with performance advantage
// over map
type Int64Set []int64

// Has returns whether set has the value
func (s *Int64Set) Has(val int64) bool {
	_, ok := s.find(val)
	return ok
}

// Remove removes the value or returns false if value is not present
func (s *Int64Set) Remove(val int64) bool {
	idx, ok := s.find(val)
	if !ok {
		return false
	}
	v := *s
	*s = append(v[:idx], v[idx+1:]...)
	return true
}

// Insert inserts the element or returns false if element already is present
func (s *Int64Set) Insert(val int64) bool {
	idx, ok := s.find(val)
	if ok {
		return false
	}

	dv := *s
	e := len(dv)
	dv = append(dv, val)
	for i := e - 1; i >= idx; i-- {
		dv[i+1] = dv[i]
	}
	dv[idx] = val
	*s = dv
	return true
}

func (s *Int64Set) find(e int64) (int, bool) {
	v := *s
	start, end := 0, len(v)
	if start == end {
		return 0, false
	}

	if end < 17 { // benchmarked value
		for i := range v {
			if v[i] == e {
				return i, true
			}
		}

		return end, false
	}

	for {
		mid := start + (end-start)/2
		val := v[mid]
		if val == e {
			return mid, true
		} else if val > e {
			end = mid + 0
		} else {
			start = mid + 1
		}

		if start == end {
			return start, start < len(v) && v[start] == e
		}
	}
}

// Int8Set uses binary search to store comparable elements
// it acts as normal Set though, with performance advantage
// over map
type Int8Set []int8

// Has returns whether set has the value
func (s *Int8Set) Has(val int8) bool {
	_, ok := s.find(val)
	return ok
}

// Remove removes the value or returns false if value is not present
func (s *Int8Set) Remove(val int8) bool {
	idx, ok := s.find(val)
	if !ok {
		return false
	}
	v := *s
	*s = append(v[:idx], v[idx+1:]...)
	return true
}

// Insert inserts the element or returns false if element already is present
func (s *Int8Set) Insert(val int8) bool {
	idx, ok := s.find(val)
	if ok {
		return false
	}

	dv := *s
	e := len(dv)
	dv = append(dv, val)
	for i := e - 1; i >= idx; i-- {
		dv[i+1] = dv[i]
	}
	dv[idx] = val
	*s = dv
	return true
}

func (s *Int8Set) find(e int8) (int, bool) {
	v := *s
	start, end := 0, len(v)
	if start == end {
		return 0, false
	}

	if end < 17 { // benchmarked value
		for i := range v {
			if v[i] == e {
				return i, true
			}
		}

		return end, false
	}

	for {
		mid := start + (end-start)/2
		val := v[mid]
		if val == e {
			return mid, true
		} else if val > e {
			end = mid + 0
		} else {
			start = mid + 1
		}

		if start == end {
			return start, start < len(v) && v[start] == e
		}
	}
}

// UintSet uses binary search to store comparable elements
// it acts as normal Set though, with performance advantage
// over map
type UintSet []uint

// Has returns whether set has the value
func (s *UintSet) Has(val uint) bool {
	_, ok := s.find(val)
	return ok
}

// Remove removes the value or returns false if value is not present
func (s *UintSet) Remove(val uint) bool {
	idx, ok := s.find(val)
	if !ok {
		return false
	}
	v := *s
	*s = append(v[:idx], v[idx+1:]...)
	return true
}

// Insert inserts the element or returns false if element already is present
func (s *UintSet) Insert(val uint) bool {
	idx, ok := s.find(val)
	if ok {
		return false
	}

	dv := *s
	e := len(dv)
	dv = append(dv, val)
	for i := e - 1; i >= idx; i-- {
		dv[i+1] = dv[i]
	}
	dv[idx] = val
	*s = dv
	return true
}

func (s *UintSet) find(e uint) (int, bool) {
	v := *s
	start, end := 0, len(v)
	if start == end {
		return 0, false
	}

	if end < 17 { // benchmarked value
		for i := range v {
			if v[i] == e {
				return i, true
			}
		}

		return end, false
	}

	for {
		mid := start + (end-start)/2
		val := v[mid]
		if val == e {
			return mid, true
		} else if val > e {
			end = mid + 0
		} else {
			start = mid + 1
		}

		if start == end {
			return start, start < len(v) && v[start] == e
		}
	}
}

// Uint16Set uses binary search to store comparable elements
// it acts as normal Set though, with performance advantage
// over map
type Uint16Set []uint16

// Has returns whether set has the value
func (s *Uint16Set) Has(val uint16) bool {
	_, ok := s.find(val)
	return ok
}

// Remove removes the value or returns false if value is not present
func (s *Uint16Set) Remove(val uint16) bool {
	idx, ok := s.find(val)
	if !ok {
		return false
	}
	v := *s
	*s = append(v[:idx], v[idx+1:]...)
	return true
}

// Insert inserts the element or returns false if element already is present
func (s *Uint16Set) Insert(val uint16) bool {
	idx, ok := s.find(val)
	if ok {
		return false
	}

	dv := *s
	e := len(dv)
	dv = append(dv, val)
	for i := e - 1; i >= idx; i-- {
		dv[i+1] = dv[i]
	}
	dv[idx] = val
	*s = dv
	return true
}

func (s *Uint16Set) find(e uint16) (int, bool) {
	v := *s
	start, end := 0, len(v)
	if start == end {
		return 0, false
	}

	if end < 17 { // benchmarked value
		for i := range v {
			if v[i] == e {
				return i, true
			}
		}

		return end, false
	}

	for {
		mid := start + (end-start)/2
		val := v[mid]
		if val == e {
			return mid, true
		} else if val > e {
			end = mid + 0
		} else {
			start = mid + 1
		}

		if start == end {
			return start, start < len(v) && v[start] == e
		}
	}
}

// Uint32Set uses binary search to store comparable elements
// it acts as normal Set though, with performance advantage
// over map
type Uint32Set []uint32

// Has returns whether set has the value
func (s *Uint32Set) Has(val uint32) bool {
	_, ok := s.find(val)
	return ok
}

// Remove removes the value or returns false if value is not present
func (s *Uint32Set) Remove(val uint32) bool {
	idx, ok := s.find(val)
	if !ok {
		return false
	}
	v := *s
	*s = append(v[:idx], v[idx+1:]...)
	return true
}

// Insert inserts the element or returns false if element already is present
func (s *Uint32Set) Insert(val uint32) bool {
	idx, ok := s.find(val)
	if ok {
		return false
	}

	dv := *s
	e := len(dv)
	dv = append(dv, val)
	for i := e - 1; i >= idx; i-- {
		dv[i+1] = dv[i]
	}
	dv[idx] = val
	*s = dv
	return true
}

func (s *Uint32Set) find(e uint32) (int, bool) {
	v := *s
	start, end := 0, len(v)
	if start == end {
		return 0, false
	}

	if end < 17 { // benchmarked value
		for i := range v {
			if v[i] == e {
				return i, true
			}
		}

		return end, false
	}

	for {
		mid := start + (end-start)/2
		val := v[mid]
		if val == e {
			return mid, true
		} else if val > e {
			end = mid + 0
		} else {
			start = mid + 1
		}

		if start == end {
			return start, start < len(v) && v[start] == e
		}
	}
}

// Uint64Set uses binary search to store comparable elements
// it acts as normal Set though, with performance advantage
// over map
type Uint64Set []uint64

// Has returns whether set has the value
func (s *Uint64Set) Has(val uint64) bool {
	_, ok := s.find(val)
	return ok
}

// Remove removes the value or returns false if value is not present
func (s *Uint64Set) Remove(val uint64) bool {
	idx, ok := s.find(val)
	if !ok {
		return false
	}
	v := *s
	*s = append(v[:idx], v[idx+1:]...)
	return true
}

// Insert inserts the element or returns false if element already is present
func (s *Uint64Set) Insert(val uint64) bool {
	idx, ok := s.find(val)
	if ok {
		return false
	}

	dv := *s
	e := len(dv)
	dv = append(dv, val)
	for i := e - 1; i >= idx; i-- {
		dv[i+1] = dv[i]
	}
	dv[idx] = val
	*s = dv
	return true
}

func (s *Uint64Set) find(e uint64) (int, bool) {
	v := *s
	start, end := 0, len(v)
	if start == end {
		return 0, false
	}

	if end < 17 { // benchmarked value
		for i := range v {
			if v[i] == e {
				return i, true
			}
		}

		return end, false
	}

	for {
		mid := start + (end-start)/2
		val := v[mid]
		if val == e {
			return mid, true
		} else if val > e {
			end = mid + 0
		} else {
			start = mid + 1
		}

		if start == end {
			return start, start < len(v) && v[start] == e
		}
	}
}

// Uint8Set uses binary search to store comparable elements
// it acts as normal Set though, with performance advantage
// over map
type Uint8Set []uint8

// Has returns whether set has the value
func (s *Uint8Set) Has(val uint8) bool {
	_, ok := s.find(val)
	return ok
}

// Remove removes the value or returns false if value is not present
func (s *Uint8Set) Remove(val uint8) bool {
	idx, ok := s.find(val)
	if !ok {
		return false
	}
	v := *s
	*s = append(v[:idx], v[idx+1:]...)
	return true
}

// Insert inserts the element or returns false if element already is present
func (s *Uint8Set) Insert(val uint8) bool {
	idx, ok := s.find(val)
	if ok {
		return false
	}

	dv := *s
	e := len(dv)
	dv = append(dv, val)
	for i := e - 1; i >= idx; i-- {
		dv[i+1] = dv[i]
	}
	dv[idx] = val
	*s = dv
	return true
}

func (s *Uint8Set) find(e uint8) (int, bool) {
	v := *s
	start, end := 0, len(v)
	if start == end {
		return 0, false
	}

	if end < 17 { // benchmarked value
		for i := range v {
			if v[i] == e {
				return i, true
			}
		}

		return end, false
	}

	for {
		mid := start + (end-start)/2
		val := v[mid]
		if val == e {
			return mid, true
		} else if val > e {
			end = mid + 0
		} else {
			start = mid + 1
		}

		if start == end {
			return start, start < len(v) && v[start] == e
		}
	}
}
